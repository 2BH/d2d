% collectfun = pleBwCluster([pars], [queue], [walltime], [useSlurm])
%
% pleBwCluster performs ple on the BwGrid by automatically
% generating scripts (startup, moab, matlab) and calling them.
%
%   pars           parameters to calculate profiles for 
%                  [all] Default value
%                 
%   queue          queue to use on the cluster. Choose between 'standard'
%                  and 'best', or leave empty for 'bestplus'.
%                  ['bestplus'] Default value
%
%   walltime       string containing walltime for jobs on cluster
%                  ['02:00:00:00'] Default value
%
%   useSlurm       [true]
%                  In 2020, the bwClusters switched from moab queuing to
%                  slurm. useSlurm=true will execute slurm commands. 
%                  useSlurm=false still writes moab-based scripts.

% The number of cores in a node is by default 5 as specified in
% arClusterConfig.m. The number of nodes is calculated from the number of pars
% (and 5 cores per node).
% 
% IMPORTANT: The fields estimatetime, fittime, timing, conf_lb, conf_ub, conf_lb_point and
%            conf_ub_point of ar.ple may not be correct (overwritten by values from the 
%            calculation of the right branch).
%
% Example 1:
%     arLoadLatest                          % load some workspace
%     pleBwCluster(1:4, 'best')             % calc. profiles of first 4 pars on best
% 
%     "Call m_20181221T154020_D13811_results.m manually after the analysis is finished!"
% 
%     m_20181221T154020_D13811_results   % follow the advice (wait and collect the results using the automatically written function)
%     results                            % results will be written into
%                                          ar.config
% 
% Example 2: 
%     collectfun = pleBwCluster             % do profiles for all pars on bestplus 
%     run(collectfun)                       % collect results workspaces
% 
% See also arClusterConfig, arWriteClusterStartup, arWriteClusterMoab, ple,
% arMergeProfiles

function collectfun = pleBwCluster(pars, queue, walltime)
global ar

if(~isfield(ar,'ple') || isempty(ar.ple))
    error('PLE ERROR: please initialize with arPLEInit')
end 

if(~isfield(ar.ple,'p_labels') || isempty(ar.ple.p_labels))
    error('PLE ERROR: please initialize with arPLEInit')
end 

if ~exist('pars','var') || isempty(pars)
    pars = 1:length(ar.p);
end

if ~exist('queue','var') || isempty(queue)
    queue = 'bestplus';
end

if ~exist('walltime','var') || isempty(walltime)
    walltime = '12:00:00';
end

if sum(strcmp(queue,{'standard','best','bestplus'})) ~= 1
    error('Queue specification invalid. Leave empty for bestplus or use standard/best');
end

if ~exist('useSlurm','var') || isempty(useSlurm)
    useSlurm = true;
end


%% configuration
fprintf('pleBwCluster.m: Generating bwGrid config ...\n');
conf = arClusterConfig;

conf.n_calls = ceil((length(pars) * 2)/conf.n_inNode);
if conf.n_calls < 2
    error('pleBwCluster.m: Must use more than one node')
end
conf.qu = queue;
conf.walltime = walltime;

profileIDs = [pars pars; [ones(1, length(pars)) zeros(1, length(pars))]; [zeros(1, length(pars)) ones(1, length(pars))]];
runIDs_tmp = 1:(length(pars)*2);
runIDs = splitArray(runIDs_tmp, conf.n_inNode);
save('pleBwClusterControl.mat', 'runIDs', 'profileIDs')

%% writing the startup bash-script:
fprintf('pleBwCluster.m: Writing startup file %s ...\n',conf.file_startup);
arWriteClusterStartup(conf);

%% writing the moab file:
if useSlurm
    fprintf('pleBwCluster.m: Writing slurm file %s ...\n',conf.file_moab);
    arWriteClusterSlurm(conf);
else
    fprintf('pleBwCluster.m: Writing moab file %s ...\n',conf.file_moab);
    arWriteClusterMoab(conf);
end

%% saving global ar in a workspace:
conf.arsavepath = ar.config.savepath;
save(conf.file_ar_workspace,'ar');

%% Writing matlab code for LHS:
fprintf('pleBwCluster.m: Writing matlab file %s ...\n',conf.file_matlab);
fprintf('pleBwCluster.m: %i profile branches in total will be calculated on %i nodes with %i jobs per node.\n',length(pars) * 2, conf.n_calls, conf.n_inNode);

WriteClusterMatlabFile(conf); 

%% starting calculation by calling the startup script:
fprintf('pleBwCluster.m: Starting job in background ...\n');
system(sprintf('bash %s\n',conf.file_startup));

%% Writing the function for collecting results:
fprintf('pleBwCluster.m: Write matlab file for collecting results ...\n');
collectfun = WriteClusterMatlabResultCollection(conf);

fprintf('-> Call %s manually after the analysis is finished!\n',conf.file_matlab_results);
if ~isempty(conf.arsavepath)
    fprintf(['ar struct in' conf.arsavepath ' will be updated with PLE results after running results function.\n']);
end
fprintf('\n \n*************************************************\nIMPORTANT: The fields estimatetime, fittime, timing, conf_lb, conf_ub, conf_lb_point and conf_ub_point of ar.ple may not be correct (overwritten by values from the calculation of the right branch).\n*************************************************\n');
end

% collectfun = WriteClusterMatlabResultCollection(conf)
function collectfun = WriteClusterMatlabResultCollection(conf)

if isempty(conf.arsavepath)
    savemcode = ['save(''',conf.file_ar_workspace,''',''ar'',''-append'');'];
    savemcodemsg = ['disp(''',conf.name,'_results.mat is written and ',conf.file_ar_workspace,' is updated.'')'];
else
    % if possible, write results in ar.config.savepath 
    savemcode = ['save(''',conf.file_ar_workspace,''',''ar'',''-append''); save(''' conf.arsavepath '/workspace.mat'',''ar'',''-append'')'];
    savemcodemsg = ['disp(''',conf.name,'_results.mat is written and ar struct in ' conf.arsavepath ' is updated.'')'];
end

mcode = {
    'function results = collectfun',...
    'olddir = pwd;',...
    ['cd ',conf.pwd], ...
    ['load(''',conf.file_ar_workspace,''',''ar'');'],...    
    ['arMergeProfiles(''' conf.pwd filesep conf.name '_PLE'',[],[], true);'],...
    '', ...
    savemcode,...    
    '',...
    savemcodemsg,...
    'cd(olddir)',...
    };

fid = fopen(conf.file_matlab_results,'w');
for i=1:length(mcode)
    fprintf(fid,'%s\n',mcode{i});
end
fclose(fid);

collectfun = [conf.pwd,filesep,conf.file_matlab_results];
end

% WriteClusterMatlabFile(conf,fitsPerCore,Nfit)
function WriteClusterMatlabFile(conf)

mcode = {
    ['cd ',conf.pwd],...
    ['addpath(''',conf.d2dpath,''');'],...
    'arInit',...
    'global ar',...
    ['load(''',conf.file_ar_workspace,''');'],...
    ['mypwd = ''',conf.pwd,''';'],...
    '',...
    '',...
    'load(''pleBwClusterControl.mat'', ''runIDs'', ''profileIDs'');',...
    'preInd = runIDs(iInNode, icall);',...
    'if preInd ~= 0',...
    '',...
    'fields = {...',...
    '    ''chi2s'',...',...
    '    ''chi2sinit'',...',...
    '    ''chi2spriors'',...',...
    '    ''chi2spriorsAll'',...',...
    '    ''chi2sviolations'',...',...
    '    ''IDstatus'',...',...
    '    ''psinit'',...',...
    '    ''ps'',...',...
    '    ''gradient'',...',...
    '    ''psinitstep'',...',...
    '    ''estimatetime'',...',...
    '    ''fittime'',...',...
    '    ''timing'',...',...
    '    ''conf_lb'',...',...
    '    ''conf_ub'',...',...
    '    ''conf_lb_point'',...',...
    '    ''conf_ub_point'',...',...
    '    ''breakon_point'',...',...
    '    ''dchi2'',...',...
    '    ''chi2_strID_ratio'',...',...
    '    ''initstep_fkt'',...',...
    '    ''minstepsize'',...',...
    '    ''breakonlb'',...',...
    '    ''breakonub'',...',...
    '    ''maxstepsize'',...',...
    '    ''plot_point'',...',...
    '    ''plot_simu'',...',...
    '    ''dist_thres'',...',...
    '    ''grad_thres'',...',...
    '    ''dchi2_point'',...',...
    '    ''merit'',...',...
    '    ''alpha_level'',...',...
    '    ''p'',...',...
    '    ''p_labels'',...',...
    '    ''ylabel'',...',...
    '    ''integrate_fkt'',...',...
    '    ''fit_fkt'',...',...
    '    ''setoptim_fkt'',...',...
    '    ''merit_fkt'',...',...
    '    ''optimset_tol'',...',...
    '    ''allowbetteroptimum'',...',...
    '    ''savePath'',...',...
    '    ''relchi2stepincrease''};',...
    '',...
    'whichP = profileIDs(:, runIDs(iInNode, icall));',...
    'ar.ple.showCalculation=0;',...
    'which ple',...
    'ple(whichP(1),[],[],[],[],[],[],[whichP(2) whichP(3)]);',...
    'if whichP(2) == 1',...
    'branch = ''L'';',...
    'elseif whichP(3) == 1',...
    'branch = ''R'';',...
    'else',...
    'branch = ''_error'';',...
    'end',...
    '', ...
    '',...
    'ple = struct;',...
    'for ifield = 1:length(fields)',...
    '    try',...
    '    ple.(fields{ifield}) = ar.ple.(fields{ifield});',...
    '    catch',...
    '    end',...
    'end',...
    '', ...
    'ple.icall = icall;',...
    'ple.iInNode = iInNode;',...
    'ple.arg1 = arg1;',...
    ['if exist([mypwd filesep ''' conf.name ''' ''_PLE/profile_'' num2str(whichP(1)) branch ''/PLE/''])~=7'],...
    ['mkdir([mypwd filesep ''' conf.name ''' ''_PLE/profile_'' num2str(whichP(1)) branch ''/PLE/''])'],...
    'end',...
    ['ple.file = [mypwd filesep ''' conf.name ''' ''_PLE/profile_'' num2str(whichP(1)) branch ''/PLE/results.mat''];'],...
    '',...
    'save(ple.file,''ple'');',...
    'end',...
    };

fid = fopen(conf.file_matlab,'w');
for i=1:length(mcode)
    fprintf(fid,'%s\n',mcode{i});
end
fclose(fid);
end

function y = splitArray(runIDs, nInNode)
runs = length(runIDs);
if mod(runs, nInNode) == 0
    y = reshape(runIDs, nInNode, []);  
else
    numOfZeros = nInNode - mod(runs, nInNode);
    y = [runIDs zeros(1, numOfZeros)];
    y = reshape(y, nInNode, []);  
end
end