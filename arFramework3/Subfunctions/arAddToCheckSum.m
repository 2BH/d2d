% checksum = arAddToCheckSum(val)
% 
%   val       any variable (handling of many classes are implemented)
% 
% 
% checksum = arAddToCheckSum(val, checksumIn)
% 
%   checksumIn    input of a previous checksum is updated (has to be in the MD5
%               format, i.e. not char)
% 
% checksum = arAddToCheckSum(val, checksum, convertToChar)
%       
%   convertToChar       default: false
% 
% 
% 
%   This function updates a checksum according to the variable val
% 
%   checksum is an instance of class
%   java.security.MessageDigest.getInstance 
%   Initialize this object by calling this function with only a single
%   argument:
%   checksum = arAddToCheckSum(val)
% 
%   This function is not used in arCompileAll to not break compatiblity
%   with old checksums. I did not find out (quickly) why this function
%   generates other checksums than the ones which are generated by the
%   commands in arCompileAll
% 
%   In the new version (from June, 21th 2018), the order of the fieldnames
%   is ignored and the fieldnames are also evaluated. This yields the
%   following behavior (which was the opposite before):
% 
%   For structs, the fieldnames are also evaluated
%   a.field1 = 10; and
%   b.field2 = 10; yields the different checksum.
% 
%   The order of fields does NOT play a role (see Example).
% 
% Example:
%   a = struct('fn1',10,'fn2',20);
%   b = struct('fn2',20,'fn1',10);
% arAddToCheckSum(a,[],true)
% arAddToCheckSum(b,[],true)


function checksum = arAddToCheckSum(val, checksum, convertToChar)
algs = {'MD2','MD5','SHA-1','SHA-256','SHA-384','SHA-512'};
if ~exist('checksum','var') || isempty(checksum)
    checksum = java.security.MessageDigest.getInstance(algs{2});
end
if ~exist('convertToChar','var') || isempty(convertToChar)
    convertToChar = false;
end

if iscell(val) && sum(cellfun(@ischar,val)~=1)==0
    val = [val{:}];  % for compatibiltiy with old checksums
    checksum = arAddToCheckSum_core(val, checksum);
elseif iscell(val) 
    for i=1:length(val)
        checksum = arAddToCheckSum(val{i},checksum);
    end
elseif isstruct(val)
    val = sortfields(val);
    fn = fieldnames(val);
    for i=1:length(fn)
        checksum = arAddToCheckSum(fn{i},checksum);
        checksum = arAddToCheckSum(val.(fn{i}),checksum);
    end
elseif isnumeric(val)
    checksum = arAddToCheckSum_core(sprintf('%d',val),checksum);
elseif ischar(val)
    checksum = arAddToCheckSum_core(val,checksum);
elseif islogical(val)
    checksum = arAddToCheckSum_core(num2str(val),checksum);
elseif isa(val, 'function_handle');
    % Technically, the function it is pointing to should also be
    % checksummed, but this is not so trivial
    checksum = arAddToCheckSum_core(char(val),checksum);
else
    class(val)
    error('arAddToCheckSum.m: Type not yet implemented. Please do it.');
end

if convertToChar
    h = typecast(checksum.digest,'uint8');
    checkstr = dec2hex(h)';
    checksum = checkstr(:)';
end


function checksum = arAddToCheckSum_core(str, checksum)
if(~isempty(str))
    checksum.update(uint8(str(:)));
end


% sout = sortfields(sin)
% 
%   Sortiert die Felder eines Structs alphabetisch.
% 
%   sin     struct
% 
%   sout    struct
function sout = sortfields(sin)
fn = sort(fieldnames(sin));

for i=1:length(fn)
    sout.(fn{i}) = sin.(fn{i});
end
